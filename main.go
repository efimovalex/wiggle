package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"sync"
	"time"

	"log/slog"

	"github.com/gen2brain/beeep"
	"github.com/go-vgo/robotgo"
	hook "github.com/robotn/gohook"
	"golang.org/x/sync/errgroup"
)

var (
	verboseFlag    *bool
	degugFlag      *bool
	idleDetection  *bool
	idleTime       *time.Duration
	wiggleInterval *time.Duration

	step int16 = 10

	sx       int
	sy       int
	displays = robotgo.DisplaysNum()

	lastTimeMoved = time.Now()

	wigglerFlag = true
	m           = sync.Mutex{}
	wiggleLock  = sync.Mutex{}

	lastX *int16
	lastY *int16

	logLvl *slog.LevelVar = &slog.LevelVar{}
	logger *slog.Logger   = slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: logLvl,
	}))
)

func main() {
	eg, ctx := errgroup.WithContext(context.Background())
	// Detect key presses and mouse actions
	// This will detect the num lock key and toggle the wiggler on and off
	// It will also detect mouse actions and turn off the wiggler if the mouse is moved
	eg.Go(func() error {
		evChan := hook.Start()
		defer hook.End()
		for {
			select {
			case <-ctx.Done():
				return nil
			case ev := <-evChan:
				// See if the event happens while the wiggler is on,
				// if so, ignore the events as they are generated by the wiggler itself
				if wiggleLock.TryLock() == false {
					// logger.Debug("Wiggler is busy, skipping event", "event", ev)
					continue
				}
				// logger.Debug("Event", "event", ev)
				switch ev.Kind {
				case hook.KeyDown:
					m.Lock()
					lastTimeMoved = time.Now()
					m.Unlock()
					if wigglerFlag {
						logger.Info("Keyboard action detected, turning off wiggler")
						toogleOff()
					}
				case hook.MouseDown:
					fallthrough
				case hook.MouseHold:
					fallthrough
				case hook.MouseUp:
					fallthrough
				case hook.MouseWheel:
					fallthrough
				case hook.MouseDrag:
					m.Lock()
					lastTimeMoved = time.Now()
					m.Unlock()
					if wigglerFlag {
						logger.Info("Mouse action detected, turning off wiggler")
						toogleOff()
					}
				case hook.MouseMove:
					if lastX == nil || lastY == nil {
						lastX = &ev.X
						lastY = &ev.Y
						lastTimeMoved = time.Now()
						break
					}
					if ev.X > *lastX+step+1 || ev.X < *lastX-step-1 {
						m.Lock()
						lastY = &ev.Y
						lastX = &ev.X
						lastTimeMoved = time.Now()
						m.Unlock()
						if wigglerFlag {
							logger.Info("Mouse moved on X axis, turning off wiggler")
							toogleOff()
						}
					} else if ev.Y != *lastY {
						m.Lock()
						lastY = &ev.Y
						lastX = &ev.X
						lastTimeMoved = time.Now()
						m.Unlock()
						if wigglerFlag {
							logger.Info("Mouse moved on Y axis, turning off wiggler")
							toogleOff()
						}
					}
				}

				wiggleLock.Unlock()
			}
		}
	})

	// Check if idle
	eg.Go(func() error {
		for {
			select {
			case <-ctx.Done():
				return nil

			case <-time.After(time.Second * 1):
				if !wigglerFlag && time.Since(lastTimeMoved) > *idleTime {
					logger.Info("Idle time exceeded, turning on wiggler")
					toogleOn()
				}
			}
		}
	})

	// Wiggler
	// This will wiggle the mouse every second if the wiggler is on
	eg.Go(func() error {
		for {
			select {
			case <-ctx.Done():
				return nil
			case <-time.After(*wiggleInterval):
				if wigglerFlag {
					wiggle()
				}
			}
		}
	})

	err := eg.Wait()
	if err != nil {
		logger.Error("Error", "error", err)
	}
}

func toogleOff() {
	m.Lock()
	defer m.Unlock()
	wigglerFlag = false
	logger.Info("Wiggler is off")
	err := beeep.Notify("Wiggler", "Wiggler is off", "./assets/icon.png")
	if err != nil {
		logger.Error("Error sending notification", "error", err)
	}
}

func toogleOn() {
	m.Lock()
	defer m.Unlock()
	wigglerFlag = true
	logger.Info("Wiggler is on")
	err := beeep.Notify("Wiggler", "Wiggler is on", "./assets/icon.png")
	if err != nil {
		logger.Error("Error sending notification", "error", err)
	}
}

func toogleWiggler() {
	if wigglerFlag {
		toogleOff()
	} else {
		toogleOn()
	}
}

func wiggle() {
	wiggleLock.Lock()
	defer wiggleLock.Unlock()
	logger.Debug("Wiggling mouse")
	step := int(step)
	robotgo.MoveSmoothRelative(step, 0)
	robotgo.MoveSmoothRelative(-2*step, 0)
	robotgo.MoveSmoothRelative(step, 0)

	robotgo.MoveSmoothRelative(step/2, 0)
	robotgo.MoveSmoothRelative(-step, 0)
	robotgo.MoveSmoothRelative(step/2, 0)
	logger.Debug("Wiggle mouse ended")
}

func computeScreenSize() {
	// Get the max witdh of all displays
	// This is used to determine the top right corner of the screen
	for i := 0; i < displays; i++ {
		x, y, w, _ := robotgo.GetDisplayBounds(i)
		if x+w > sx {
			sx = x + w
		}
		if y < sy {
			sy = y
		}
	}

}

func init() {
	logLvl.Set(slog.LevelError)

	flag.Usage = func() {
		fmt.Print("\nUsage: wiggler [options] \n\nOptions:\n" +
			" -h                 Show this help message \n" +
			" -v                 Enable verbose logging\n" +
			" -vvv               Enable debug logging\n" +
			" -idle-time         Set idle time in seconds. Default is 10 seconds. Example: -idle-time=5s\n" +
			" -wiggle-interval   Set wiggle interval in seconds. Default is 1 second. Example: -wiggle-interval=2s\n")
	}
	// read flags
	verboseFlag = flag.Bool("v", false, "verbose")
	degugFlag = flag.Bool("vvv", false, "debug")
	idleTime = flag.Duration("idle-time", 30*time.Second, "idle time in seconds")
	wiggleInterval = flag.Duration("wiggle-interval", 5*time.Second, "wiggle interval in seconds")

	flag.Parse()
	if *verboseFlag {
		logLvl.Set(slog.LevelInfo)
	} else if *degugFlag {
		logLvl.Set(slog.LevelDebug)
	}

	robotgo.MouseSleep = 100
	computeScreenSize()

}
